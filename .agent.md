# Gemini Project Analysis: werewolf-game-master

This document provides an AI-generated overview of the `werewolf-game-master` project, designed to be used as instructional context for future interactions with Gemini. This version reflects the new Event-Driven architecture.

## Project Overview

This is a web application for playing the social deduction game Werewolf (Ma SÃ³i). It is built using Next.js, React, and TypeScript.

**Key Technologies:**

- **Framework:** Next.js 15 (with App Router)
- **Language:** TypeScript
- **UI Library:** React 19
- **Styling:** Tailwind CSS
- **UI Components:** shadcn/ui - A collection of re-usable components that can be copied and pasted into your apps.

### Core Architecture: Event-Driven

The project is built on a flexible and scalable **Event-Driven Architecture**. This decouples the core game logic from the roles, making the system easy to extend and maintain.

- **`GameEngine` (Event Broadcaster & Orchestrator):** The heart of the application. It manages the main game loop and state. Its primary responsibility is to **broadcast `GameEvent` objects** (e.g., `PHASE_CHANGED`, `PLAYER_DIED`) to all roles. It executes `Action` objects and enforces `RuleSet` policies. It acts as the central orchestrator of game flow.

- **`Role` (Event Listener & Action Factory):** Each role class (e.g., `Seer`, `Hunter`) implements the `IRole` interface. Its main method, `onGameEvent`, listens for events from the `GameEngine`. If an event is relevant, the role can react. The role also acts as a **factory** that creates `Action` objects based on player input via its `createAction` method.

- **`Action` (Command Object):** A self-contained command that holds all the information needed to perform a single game action (e.g., `KillAction`, `SeeAction`). It has an `execute()` method that directly mutates the game state. Actions are created by Roles and executed by the GameEngine.

- **`RuleSet` (Game Policy Provider):** An implementation of `IRoleSet` (e.g., `StandardRuleSet`). It defines the specific rules and policies of the game (e.g., win conditions, whether Witch can heal herself, night turn order). The `GameEngine` queries the `RuleSet` to enforce these policies.

- **`GameState` (Single Source of Truth):** A central object that holds the entire current state of the game, including players, their roles, current phase, day number, and temporary nightly actions/results. All `Action` objects modify this state.

- **`Player`:** Represents a single player in the game, holding their ID, name, and their assigned `IRole` instance, along with various status flags (e.g., `isAlive`, `isProtected`, `isMarkedForDeath`).

- **`GameEvent`:** Defines the structure for all game events, forming the backbone of the new architecture. Events are broadcast by the `GameEngine` and listened to by `Role` objects.

- **`useGame.ts` (The Bridge):** A React hook that connects the UI to the `GameEngine`. It provides methods for the UI to send player input (e.g., `submitPlayerAction`, `submitVote`), and exposes the game state for rendering.

## Design Patterns in werewolf-game-master

This project leverages several well-established design patterns to achieve its flexible and maintainable architecture:

### 1. Event-Driven Architecture / Observer Pattern

- **Description:** Components communicate by publishing and subscribing to events, rather than direct method calls. This reduces coupling between modules.
- **Specific Application:**
  - **Subject/Publisher:** `GameEngine` broadcasts `GameEvent` objects (e.g., `PHASE_CHANGED`, `PLAYER_DIED`).
  - **Observer/Subscriber:** `IRole` implementations (e.g., `Werewolf`, `Seer`, `Witch`) via their `onGameEvent` method.
  - **Event:** `GameEvent` objects carry information about what happened in the game.
- **Benefits:** Decouples event producers from consumers, allowing for flexible reactions to game state changes and easier addition of new event types or roles.

### 2. Command Pattern

- **Description:** Encapsulates a request (an action) as an object, allowing for parameterization of clients with different requests, queuing or logging requests, and supporting undoable operations.
- **Specific Application:**
  - **Command:** `IAction` interface and its concrete implementations (e.g., `KillAction`, `HealAction`, `SeeAction`).
  - **Receiver:** `GameState` (the object that `execute()` methods operate on).
  - **Invoker:** `GameEngine` (queues and executes `Action` objects).
  - **Client:** `Role` objects (create `Action` objects).
- **Benefits:** Decouples the requestor from the executor and the object being acted upon. Enables flexible management, queuing, and processing of actions.

### 3. Factory Pattern

- **Description:** Provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.
- **Specific Application:**
  - **Simple Factory (for Role creation):** `roleMap` in `src/game-core/roles/index.ts` acts as a simple factory to create `IRole` instances.
  - **Factory Method (for Action creation within Roles):** The `IRole` interface defines the `createAction()` method, and concrete `Role` classes implement it to produce their specific `Action` objects.
- **Benefits:** Centralizes object creation logic and delegates `Action` creation to the `Role`s themselves.

### 4. Decorator Pattern

- **Description:** Dynamically attaches new responsibilities to an object.
- **Specific Application:** The `LoverRoleDecorator` wraps an existing `IRole` instance to modify its `faction` and `description` without altering the original role class.
- **Benefits:** Allows for dynamic modification of `Role` properties without changing the base `Role` class, crucial for mechanics like the "Lovers" faction.

### 5. Singleton Pattern (Conceptual)

- **Description:** Ensures a class has only one instance and provides a global point of access to it.
- **Specific Application:** `GameEngine` and `GameState` are conceptually managed as single instances throughout the application to ensure a single source of truth and central control for the game.
- **Note:** This is a conceptual application rather than a strict code enforcement (e.g., private constructors).

## Building and Running

- **Run the development server:**

  ```bash
  npm run dev
  ```

- **Build for production:**

  ```bash
  npm run build
  ```

- **Start the production server:**

  ```bash
  npm run start
  ```

- **Lint the code:**
  ```bash
  npm run lint
  ```

## Development Conventions

### Game Logic Flow (Event-Driven)

1.  The `GameEngine` initiates a change (e.g., starts a new phase) or processes player actions, and **broadcasts a `GameEvent`**.
2.  All living `Role` objects receive the event via their `onGameEvent` method.
3.  A `Role` that cares about the event can update its internal state or prepare for action.
4.  The UI, using data from the `Role`'s `getActionOptions` method, presents options to the user.
5.  The user performs an action in the UI.
6.  The UI calls a `GameEngine` method (e.g., `submitPlayerAction`, `submitVote`), passing a payload.
7.  The `GameEngine` validates the action (consulting the `RuleSet` if necessary) and forwards the payload to the relevant `Role`'s `createAction` method.
8.  The `Role` creates and returns an `Action` object (or an array of `Action`s).
9.  The `GameEngine` receives the `Action` object(s), places it in a queue (e.g., `nightActionQueue`, `immediateActionQueue`), and executes it at the appropriate time (e.g., during `resolveNight`).
10. The execution of the `Action` directly mutates the `GameState`.
11. The `GameEngine` then checks win conditions (`RuleSet.checkWinConditions`) and may broadcast another `GameEvent` (e.g., `PLAYER_DIED`, `PHASE_CHANGED`), continuing the cycle.

### Key `GameEngine` Methods & Their Responsibilities

- **`_broadcastEvent(event: GameEvent)`:** Pushes the event to `gameHistory` and dispatches it to all living `Role`s via `onGameEvent`. Also handles immediate actions like Lover death.
- **`submitPlayerAction(playerId: string, payload: unknown)`:** Entry point for player-initiated actions. Validates the action (e.g., `canKillOnFirstNight`, Witch potion rules) and queues the resulting `Action`s.
- **`submitVote(voterId: string, targetId: string)`:** Records a single vote from a player. Used by GM to track voting.
- **`resolveNight()`:** Executes all queued night actions, determines deaths (considering protection/healing), broadcasts `PLAYER_DIED` events, processes immediate actions, checks win conditions, and transitions to the day phase.
- **`resolveVoting(votedPlayerId: string | null)`:** Processes the outcome of the voting phase. Accepts the ID of the player voted out (or null if no one is executed), eliminates them, broadcasts `PLAYER_DIED`, checks win conditions, and transitions to the next phase.
- **`_processImmediateActions()`:** Executes actions that need to happen immediately (e.g., Hunter's shot after death).
- **`getGMNightOrder()`:** Queries the `RuleSet` to get the defined night turn order for GM display.

### Adding a New Role (The Modern Workflow)

1.  **Define Action(s):** If the role has unique abilities, create new `IAction` classes in `src/game-core/actions/`.
2.  **Create Role Class:** Create a new class in `src/game-core/roles/` that implements the `IRole` interface.
3.  **Implement `onGameEvent`:** This is the most critical step. Code the logic to react to specific game events. For a night-acting role, you'll react to `PHASE_CHANGED` to `'NIGHT'`. For a role like the Hunter, you'll react to `PLAYER_DIED`.
4.  **Implement `createAction`:** Write the factory logic that takes a payload from the UI and returns a new instance of your `Action` class (or an array of `Action`s). This method should also contain any role-specific validation (e.g., Witch checking if she has potions left).
5.  **Implement `getActionOptions`:** Provide the data needed for the UI to render the controls for your role (e.g., a list of valid targets).
6.  **Register Role:** Add the new role to the `roleMap` in `src/game-core/roles/index.ts`.

### Adding a shadcn/ui Component

- Run the following command, replacing `<component-name>` with the desired component:
  ```bash
  npx shadcn@latest add <component-name>
  ```
- The new component will be added to `src/components/ui/`.

### Code Style & Naming

- Adhere to the rules in `eslint.config.mjs`.
- Use PascalCase for components, classes, types, and enums (e.g., `PlayerCard`, `GameEngine`, `GameState`).
- Use the `use` prefix for hooks (e.g., `useGame`).

## Important Reminders

- **GM-Centric System:** This system is primarily designed for a Game Master (GM) to control and manage the Werewolf game. Many actions and transitions are expected to be initiated or confirmed by the GM via the UI.
- **Adherence to Design Patterns:** All new features, modifications, or additions to the `game-core` must strictly adhere to the established Event-Driven architecture and design patterns (e.g., Command, Factory, Decorator, Observer). This ensures maintainability, scalability, and consistency of the codebase.
